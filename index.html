<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Spicuzza</title>

    <style>
        body {
            margin: 0;
        }
        
        canvas {
            display: block;
        }
    </style>

    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css">
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/mdb.min.css" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="css/index.css">
</head>

<body>
    <div id="root">
        <header>
            <a href="#">Projects</a>
            <a href="#">Bio</a>
            <h1>Spicuzza</h1>
            <a href="#">Resume</a>
            <a href="#">Contact</a>
        </header>

        <div class="arrow-down">
           <i class="fas fa-angle-double-down fa-3x"></i>
        </div>

        <div id="landing-grid">
            <div></div>
            <div></div>
        </div>
        <main>

        </main>

        <footer>
            <div id="social">
                <ul>
                    <li><a href="#">Github</a></li>
                    <li><a href="#">Blog</a></li>
                </ul>
            </div>
            <div id="other">
                <p>Other Section</p>
            </div>
        </footer>
    </div>
    <script src="js/three.js"></script>


    <script>
        var clusters = []; // container for generated clusters

        const randomInt = (max = 10, min = 0) => {
            const res = Math.floor(Math.random() * Math.floor(max));
            return res > min ? res : min;
        };
        const clusterCount = 20; // count of total clusters
        const clusterMinCount = 5;
        const clusterMaxCount = 10;

        //#region scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
            75, // FoV
            window.innerWidth / window.innerHeight, // aspect ratio
            0.1, // inner camera plane
            1000 // outer camera plane
        );
        camera.position.z = 5;
        //#endregion


        //#region renderer setup
        const renderer = new THREE.WebGLRenderer({
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        renderer.setClearColor("rgb(20 , 20 , 20)")

        window.addEventListener("resize", (event) => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;

            camera.updateProjectionMatrix(); // needs to be run on resize
        })

        const render = () => {
                renderer.render(scene, camera);
            }
            //#endregion


        //#region Lighting
        const ambient = new THREE.AmbientLight(0x404040);
        scene.add(ambient);

        const pointLight = new THREE.PointLight(0x404040);
        pointLight.position.set(50, 50, 50);
        scene.add(pointLight);
        //#endregion

        //#region Mesh Generators
        function generateCluster() {
            const material = new THREE.MeshLambertMaterial({
                color: 0x888888
            });

            let clusterGroupObj = new THREE.Group();
            scene.add(clusterGroupObj);

            let clusterRange = randomInt(clusterMaxCount);
            if (clusterRange > clusterMinCount) clusterRange = clusterMinCount;

            for (let j = 0; j < clusterRange; j++) {
                let clusterRange = randomInt(clusterMaxCount);
                if (clusterRange > clusterMinCount) clusterRange = clusterMinCount;
                const x = Math.random(1, 20);
                const y = Math.random(1, 20);
                const z = Math.random(1, 20);

                const geometry = new THREE.BoxGeometry(x, y, z);
                const cube = new THREE.Mesh(geometry, material);
                scene.add(cube);
                clusterGroupObj.add(cube);
                clusters.push(clusterGroupObj);

                console.log(x, y, z)
                    //return clusterGroupObj;
            }
        }

        // requires a Mesh and 2 Vector3 objects ( $ new THREE.Vector3(x , y , z); )
        function randomizePosition(obj, minVector3, maxVector3) {
            const randomInRange = (min = 1, max = 1) => {
                return Math.floor(Math.random() * max) + min
            }

            obj.position = (
                randomInRange(minVector3.x, maxVector3.x),
                randomInRange(minVector3.y, minVector3.y),
                randomInRange(minVector3.z, maxVector3.z)
            )
        }

        function randomizeScale(obj, min, max) {

        }


        //#endregion

        function generateBackground() {
            for (let i = 0; i < clusterCount; i++) {
                generateCluster();
            }

            //TODO: randomize positions
        }
        generateBackground();



        const update = () => {}

        const realTimeLoop = () => {
            requestAnimationFrame(realTimeLoop);
            update();
            render();
        }

        realTimeLoop();
    </script>
</body>

</html>