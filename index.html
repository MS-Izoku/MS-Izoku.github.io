<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Spicuzza</title>

    <style>
        body {
            margin: 0;
        }
        
        canvas {
            display: block;
        }
    </style>

    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css">
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/mdb.min.css" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="css/index.css">
</head>

<body>
    <div id="root">
        <header>
            <a href="#">Projects</a>
            <a href="#">Bio</a>
            <h1>Spicuzza</h1>
            <a href="#">Resume</a>
            <a href="#">Contact</a>
        </header>

        <div class="arrow-down">
            <i class="fas fa-angle-double-down fa-3x"></i>
        </div>

        <div id="landing-grid">
            <div></div>
            <div></div>
        </div>
        <main>

        </main>

        <footer>
            <div id="social">
                <ul>
                    <li><a href="#">Github</a></li>
                    <li><a href="#">Blog</a></li>
                </ul>
            </div>
            <div id="other">
                <p>Other Section</p>
            </div>
        </footer>
    </div>
    <script src="js/three.js"></script>


    <script>
        var clusters = []; // container for generated clusters

        const randomInt = (max = 10, min = 0) => {
            const res = Math.floor(Math.random() * Math.floor(max));
            return res > min ? res : min;
        };
        const clusterCount = 20; // count of total clusters
        const clusterMinCount = 5;
        const clusterMaxCount = 10;

        //#region scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
            75, // FoV
            window.innerWidth / window.innerHeight, // aspect ratio
            0.1, // inner camera plane
            1000 // outer camera plane
        );
        camera.position.z = 5;
        console.dir(camera);
        //#endregion


        //#region renderer setup
        const renderer = new THREE.WebGLRenderer({
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        renderer.setClearColor("rgb(250 , 250 , 250)")

        window.addEventListener("resize", (event) => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;

            camera.updateProjectionMatrix(); // needs to be run on resize
        })

        const render = () => {
                renderer.render(scene, camera);
            }
            //#endregion


        //#region Lighting
        const pointLight = new THREE.PointLight(0x404040);
        pointLight.position.set(1, 1, 3);
        scene.add(pointLight);

        const directionalLight = new THREE.DirectionalLight({
            color: "FFFFFF",
            intensity: 1
        });

        //TODO: Adjust angles
        scene.add(directionalLight);
        // const directionalTarget = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshPhongMaterial("#ffffff"));
        // scene.add(directionalTarget);
        //#endregion

        //#region Mesh Generators
        const cubeMaterial = new THREE.MeshPhongMaterial({
            color: "#ffffff"
        })

        function generateCube(size, position, group = null) {
            const cubeGeometry = new THREE.BoxGeometry(size.x, size.y, size.z);
            const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
            scene.add(cube);
            cube.position.set(position.x, position.y, position.z);
            if (group != null) group.add(cube);
            return cube;
        }
        //#endregion

        function generateBackground() {

            const cluster1 = () => {
                const group = new THREE.Group();
                scene.add(group);
                const cube1 = generateCube(new THREE.Vector3(2, 2.25, 2), new THREE.Vector3(-0.25, 0, 0.5), group);
                const cube2 = generateCube(new THREE.Vector3(2, 2.5, 2.5), new THREE.Vector3(0, -0.5, 0), group);
                const cube3 = generateCube(new THREE.Vector3(1.75, 1, 1), new THREE.Vector3(0, -2, 0), group);
                const cube4 = generateCube(new THREE.Vector3(3, 2, 0), new THREE.Vector3(0.5, 0, 0.25), group);
                const cube5 = generateCube(new THREE.Vector3(1.5, 1.5, 1.5), new THREE.Vector3(0.75, -1.5, -0.5), group);
                const cube6 = generateCube(new THREE.Vector3(2, 3, 1), new THREE.Vector3(-1., -0.5, 0.5), group);
                const cube7 = generateCube(new THREE.Vector3(1, 1, 1), new THREE.Vector3(-1, -1.75, 0), group);

                group.position.set(-5.5, 1.75, -1);
                return group;
            }

            const cluster2 = () => {
                const group = new THREE.Group();
                scene.add(group);
                const cube1 = generateCube(new THREE.Vector3(2.5, 2, 3), new THREE.Vector3(0.5, 0.5, 0), group);
                const cube2 = generateCube(new THREE.Vector3(1.5, 1.5, 1.5), new THREE.Vector3(0.25, -0.25, 0.5), group);
                const cube3 = generateCube(new THREE.Vector3(3, 2, 0), new THREE.Vector3(0, -1, 0), group);
                const cube4 = generateCube(new THREE.Vector3(2, 3, 2), new THREE.Vector3(-1, -0.25, 0), group);
                group.position.set(5.5, 2, -1);
                return group
            }

            const cluster3 = () => {
                const group = new THREE.Group();
                scene.add(group);
                const cube1 = generateCube(new THREE.Vector3(1.5, 2.25, 1.5), new THREE.Vector3(0, 0, 0), group);
                const cube2 = generateCube(new THREE.Vector3(1, 2, 1), new THREE.Vector3(-0.5, -.5, 0.5), group);
                const cube3 = generateCube(new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, -1.5, -0.25), group);
                const cube4 = generateCube(new THREE.Vector3(1.5, 2, 1), new THREE.Vector3(0.5, -0.5, 0), group);
                const cube5 = generateCube(new THREE.Vector3(1, 0.5, 0.5), new THREE.Vector3(0, -1, 0.5), group);
                const cube6 = generateCube(new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0), group);
                group.position.set(2.5, 3, -5);
                return group
            }


            // Non-Proceedural Cluster Generation Template
            // const cluster3 = () =>{
            //     const group = new THREE.Group();
            //     scene.add(group);
            //     const cube1 = generateCube(new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0), group);
            //     const cube2 = generateCube(new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0), group);
            //     const cube3 = generateCube(new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0), group);
            //     const cube4 = generateCube(new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 0, 0), group);
            //     group.position.set(0, 0, 0);
            //     return group
            // }


            const plane = (function() {
                const planeGeometry = new THREE.PlaneGeometry(30, 4);
                const planeMaterial = new THREE.MeshLambertMaterial({
                    color: "rgb(255 , 255 , 255)"
                })
                const planeMesh = new THREE.Mesh(planeGeometry, planeMaterial)
                scene.add(planeMesh);
                planeGeometry.lookAt(new THREE.Vector3(0, 1, 0))
                planeMesh.position.set(0, -3, 0)
                return planeMesh
            }())

            const generateWalls = (function() {
                const wallGroup = new THREE.Group();
                scene.add(wallGroup);
                const boundary = () => window.innerWidth / window.innerHeight * 50;
                const depth = () => -window.innerWidth / window.innerHeight * 35;
                const height = () => window.innerWidth / window.innerHeight * 10;

                const wallGeometry = new THREE.BoxGeometry(180, 50, 30);
                const wall = () => {
                    const wallMesh = new THREE.Mesh(wallGeometry, cubeMaterial)
                    scene.add(wallMesh);
                    wallGroup.add(wallMesh);
                    return wallMesh;
                }
                
                const backWall = wall();
                backWall.position.set(0 , 15 , -50);
                
            }())

            cluster1().scale.set(1 , 1.5 , 1);
            cluster2();
            cluster3();
        }
        generateBackground();



        const update = () => {}
        const realTimeLoop = () => {
            requestAnimationFrame(realTimeLoop);
            update();
            render();
        }

        realTimeLoop();
    </script>
</body>

</html>