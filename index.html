<!DOCTYPE html>
<html>

<head>
    <link rel="stylesheet" type="text/css" href="css/index.css">
    <title>Spicuzza</title>

    <style>
        body {
            margin: 0;
        }
        
        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <div id="root">
        <header>
            <a href="#">Projects</a>
            <a href="#">Bio</a>
            <h1>Spicuzza</h1>
            <a href="#">Resume</a>
            <a href="#">Contact</a>
        </header>

        <main>
            <p>When I was a wee lad</p>
        </main>

        <footer>
            <div id="social">
                <ul>
                    <li><a href="#">Github</a></li>
                    <li><a href="#">Blog</a></li>
                </ul>
            </div>
            <div id="other">
                <p>Other Section</p>
            </div>
        </footer>
    </div>
    <script src="js/three.js"></script>


    <script>
        var clusters = []; // container for generated clusters

        const randomInt = (max = 10, min = 0) => {
            const res = Math.floor(Math.random() * Math.floor(max));
            return res > min ? res : min;
        };
        const clusterCount = 20; // count of total clusters
        const clusterMinCount = 5;
        const clusterMaxCount = 10;

        //#region scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
            75, // FoV
            window.innerWidth / window.innerHeight, // aspect ratio
            0.1, // inner camera plane
            1000 // outer camera plane
        );
        camera.position.z = 5;
        //#endregion


        //#region renderer setup
        const renderer = new THREE.WebGLRenderer({
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        renderer.setClearColor("rgb(20 , 20 , 20)")

        window.addEventListener("resize", (event) => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;

            camera.updateProjectionMatrix(); // needs to be run on resize
        })

        const render = () => {
            renderer.render(scene, camera);
        }
        //#endregion


        //#region Lighting
        const ambient = new THREE.AmbientLight(0x404040);
        scene.add(ambient);

        const pointLight = new THREE.PointLight(0x404040);
        pointLight.position.set(50, 50, 50);
        scene.add(pointLight);
        //#endregion

        //#region Mesh Generators
        function generateCluster() {
             const material = new THREE.MeshLambertMaterial( { color: 0x888888 } );

            let clusterGroupObj = new THREE.Group();
            scene.add(clusterGroupObj);

            let clusterRange = randomInt(clusterMaxCount);
            if (clusterRange > clusterMinCount) clusterRange = clusterMinCount;

            for (let j = 0; j < clusterRange; j++) {
                let clusterRange = randomInt(clusterMaxCount);
                if (clusterRange > clusterMinCount) clusterRange = clusterMinCount;
                const x = Math.random(1, 20);
                const y = Math.random(1, 20);
                const z = Math.random(1, 20);

                console.log("XYZ", x, y, x);
                const geometry = new THREE.BoxGeometry(x, y, z);
             
                const cube = new THREE.Mesh(geometry, material);
                scene.add(cube);
                clusterGroupObj.add(cube);
                clusters.push(clusterGroupObj);
            }
        }

        function randomizePosition(obj , min , max){

        }

        function randomizeScale(obj , min , max){

        }


        //#endregion

        function generateBackground() {
            for(let i = 0; i < clusterCount; i++){
                generateCluster();
            }
        }
        generateBackground();



        const update = () => {}

        const realTimeLoop = () => {
            requestAnimationFrame(realTimeLoop);
            update();
            render();
        }

        realTimeLoop();
    </script>
</body>

</html>